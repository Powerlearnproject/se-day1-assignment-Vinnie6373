[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15575476&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
**Software Engineering** is the systematic application of engineering principles to the design, development, testing, maintenance, and management of software systems. It involves using scientific methods, engineering best practices, and advanced technology to build reliable, efficient, and scalable software products that meet specified user requirements.

**Importance of Software Engineering in the Technology Industry**
**Building Complex Systems**:

In today's digital world, software systems are highly complex and require careful planning and design. Software engineering provides structured approaches to manage this complexity, ensuring systems are robust, maintainable, and scalable.
For example, developing large-scale applications like enterprise resource planning (ERP) systems, financial platforms, or cloud infrastructure involves millions of lines of code and multiple interconnected components. Software engineering helps break down this complexity into manageable tasks.
Ensuring Quality and Reliability:

Software failures can result in costly downtime, data loss, or even safety risks. Software engineering introduces best practices for ensuring quality, such as rigorous testing, version control, and code reviews.
In industries like aviation, healthcare, and banking, software failures can have catastrophic consequences. Software engineering ensures these critical systems operate reliably and safely.
**Efficiency and Optimization:**

Software engineers use optimization techniques to ensure systems run efficiently, using minimal resources like CPU power, memory, and network bandwidth. This is particularly important for large-scale applications that serve millions of users.
Examples include cloud-based services or search engines that must process vast amounts of data in real-time without delays.
**Collaboration and Scalability:**

Modern software projects involve large, distributed teams working on different parts of a project. Software engineering introduces collaboration practices, such as agile methodologies and version control, to manage this teamwork effectively.
Large tech companies like Google or Microsoft have thousands of developers working on the same product, and they rely on software engineering principles to coordinate this work and ensure the system remains scalable as it grows.
**Cost and Time Efficiency:**

By applying project management and planning techniques, software engineering helps reduce the time and cost of software development. Engineers create detailed schedules, milestones, and budgets, allowing projects to be completed on time and within budget.
This structured approach helps companies avoid common pitfalls like scope creep, missed deadlines, and over-budget projects.
**Continuous Improvement:**

Software engineering emphasizes the importance of maintaining and improving software over time through updates, bug fixes, and optimizations. This is essential in today's fast-paced tech world, where software must evolve to stay competitive and meet new user demands.
Techniques like DevOps and continuous integration/continuous deployment (CI/CD) enable teams to release frequent updates without disrupting the user experience.
**Innovation and Problem Solving:**

Software engineers are at the forefront of technological innovation. Whether it's artificial intelligence (AI), machine learning, blockchain, or virtual reality (VR), software engineers drive the creation of new solutions that revolutionize industries.
Many tech innovations, like self-driving cars, smart homes, and virtual assistants (e.g., Amazon Alexa, Google Assistant), are made possible by advances in software engineering.


Identify and describe at least three key milestones in the evolution of software engineering.
**The Birth of High-Level Programming Languages (1950s–1960s)**
The introduction of high-level programming languages in the 1950s and 1960s marked a critical milestone in software engineering. Before this, software development was done using assembly language or machine code, which made programming tedious, error-prone, and difficult to scale.

**The Introduction of Structured Programming (1960s–1970s)**

In the 1960s and 1970s, software development was facing a "software crisis" where projects were becoming increasingly large and complex, often resulting in failures, delays, and cost overruns. To address these challenges, structured programming was introduced, advocating for better organization and modularization of code.

Key principles of structured programming included:

Breaking programs into smaller, self-contained modules or functions.
Using control structures like loops, conditionals, and subroutines to create clear, logical flows.
Avoiding “GOTO” statements, which led to chaotic and unmaintainable "spaghetti code."

 **The Emergence of Agile Methodologies (1990s–2000s)**

By the late 20th century, the rapid pace of technological change, especially in software, exposed the limitations of traditional, rigid methodologies like Waterfall. The Agile Manifesto was introduced in 2001, representing a significant shift toward more flexible and iterative development practices.
**Agile methodologies emphasized:**

Iterative Development: Delivering small, incremental improvements to software rather than waiting until the project is fully completed.
Collaboration: Continuous interaction between development teams and customers or stakeholders.
Adaptability: Flexibility in responding to changes in requirements, even late in the development process.
Customer Focus: Prioritizing customer satisfaction through continuous delivery of valuable software.

List and briefly explain the phases of the Software Development Life Cycle.
• The lifecycle model views software as being developed in six 
distinct stages namely: requirement analysis, specifications, 
design, implementation, testing and adaptation.
• **Requirements analysis and specification** involve interaction among sponsors, users and developers of the software product. The purpose of requirement analysis is to produce a requirement document
• It specifies the agreed upon goals and the functionality of the proposed product as well as the constraint under which it will be operating.
• **Design** **involves the generation of a design document to serve as a blue print for the proposed system. Developers and adaptors are usually involved in this process.
Adaptors are involved in order to help assure that the design is conuity with a graceful evolution of the system
**Implementation** involves building the system described in the design document. This includes making important decisions about data structures and algorithms as well as writing the program code itself. 
These decisions can have significant impact upon the efficiency  of the system
• **Testing** involves detecting as many defects in the software system as possible. Unit testing seeks to find defects in individual software components (such as functions) while integration testing seeks to find defects which might arise when assembled components fail to work correctly in concert with one another.
.**Adaptation (maintenance)** refers to the evolution of the completed system.
• The software lifecycle model in practice is not perfectly sequential. There are loops which feedback from later stages to earlier ones in the cycle. For example the discovery of an error during integration testing could force the developer to go back to the implementation or the design stage

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
**Linear and Sequential**: Waterfall is a traditional project management methodology where the development process is divided into distinct phases such as requirements gathering, design, implementation, testing, and maintenance.
Structured Phases: Each phase must be completed before moving on to the next, and once a phase is completed, going back to change something is typically difficult and costly.
**Documentation-Heavy**: Each phase has specific deliverables and thorough documentation. Detailed upfront planning is emphasized.
**Advantages**:

**Predictability**: With clear, structured stages, it's easy to measure progress, and the project timeline and budget are predictable.
Best for Fixed Scope: Well-suited for projects with stable, well-understood requirements that are unlikely to change.
Documentation: Detailed documentation helps onboarding new team members and ensures continuity even if team members change.
**Disadvantages**:

**Inflexibility**: It's hard to make changes once the project is underway. If client needs evolve, it can be costly and time-consuming to adjust.
Longer Time to Market: Since the project must go through each phase, there's no early delivery or opportunity for partial deployments.
Example of Scenario:

**Construction Projects**: Building a physical structure like a bridge or skyscraper has very defined stages (e.g., design, approval, construction), and changes after the fact would be costly or impractical.
**Hardware Development**: Designing and manufacturing electronic devices often follow Waterfall because each stage (from design to production) requires sequential completion and exact specifications.
**Agile Methodology**
Overview:

**Iterative and Incremental**: Agile is a flexible approach that focuses on small, iterative cycles called "sprints" (often 2-4 weeks), during which a part of the product is developed, tested, and delivered.
Emphasis on Collaboration: Frequent communication between developers and stakeholders ensures the project can adapt quickly to changes in requirements or user feedback.
**Less Documentation, More Collaboration:** Agile relies more on direct communication and teamwork rather than exhaustive documentation.
**Advantages:**

**Flexibility**: Agile accommodates changes in scope and requirements, even late in the project lifecycle, allowing teams to pivot based on feedback.
Continuous Delivery: Teams can deliver working software incrementally, providing immediate value to users and stakeholders.
**Collaboration**: Agile encourages continuous feedback from clients, improving satisfaction and aligning the final product more closely with client expectations.
**Disadvantages:**

**Less Predictability:** Since requirements can evolve and the process is iterative, it’s harder to predict the final product timeline or budget.
Requires Active Client Involvement: Constant client feedback is crucial, which might be a challenge for clients who are unable to commit enough time.
**Scaling Challenges:** While Agile works well for small teams, managing large-scale Agile projects across multiple teams can introduce complexities.
**Example of Scenario**:

**Software Developmen**t: In a project where user needs and technologies evolve quickly, such as developing a mobile app or website, Agile allows the team to quickly adapt to feedback and changing requirements.
**Startups**: In fast-paced environments where quick pivots and adjustments are common based on market needs, Agile is an ideal choice due to its focus on rapid iteration and flexibility.
**Comparison of Waterfall and Agile**:
Waterfall;Rigid changes are difficult and costly 
Agile,Highly flexible, adapts to changes throughout
Waterfall;Defined phases: Requirements → Design → Implementation → Testing → Maintenance
Agile;Defined phases: Requirements → Design → Implementation → Testing → Maintenance
waterfall;Risks are identified at the start
Agile;Risks managed and mitigated throughout the project
**Choosing the Right Methodology:**

Waterfall is best suited for:
Projects with clear, unchanging requirements.
Projects where strict regulations or compliance issues exist (e.g., healthcare or defense).
Projects where stakeholders are not available for continuous involvement.
Agile is best suited for:
Projects where requirements are likely to evolve.
Projects with a high level of uncertainty or innovation.
Projects that require quick delivery of usable features (e.g., software startups).







Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
**Software Developer**
Role:
Software developers (or engineers) are responsible for designing, coding, and implementing software applications. They translate functionalrequirements into technical specifications and build software solutions that meet these requirements.

Responsibilities:

Writing Code: Develop and maintain software applications by writing clean, efficient, and scalable code based on requirements.
Software Design: Participate in designing software architecture, data models, and user interfaces.
Collaboration: Work closely with other developers, QA engineers, designers, and business stakeholders to ensure the software meets expectations.
Bug Fixing: Identify, troubleshoot, and fix software bugs and performance issues during development and post-deployment.
Documentation: Maintain technical documentation of the code, APIs, and system architecture.
Testing: Conduct unit testing and collaborate with QA teams to ensure the software is functional and bug-free.
Continuous Learning: Keep up to date with new technologies, frameworks, and best practices to improve the development process.
**Example Task**:

Building the back-end API for a mobile application or developing the front-end user interface for a web app.

**Quality Assurance (QA) Engineer**
Role:
QA engineers ensure the software product meets the required quality standards before it is released to users. They systematically test the software for functionality, performance, security, and usability, and ensure it is free from defects.

Responsibilities:

Test Planning: Develop comprehensive test plans, test cases, and test scripts based on the product's requirements and specifications.
Manual Testing: Execute manual testing processes, including functional, integration, usability, and user acceptance testing.
Automation Testing: Implement automated tests using testing frameworks to ensure consistency and efficiency in test execution.
Bug Tracking and Reporting: Identify, document, and report software defects, working closely with developers to reproduce and resolve issues.
Regression Testing: Re-test software after changes to ensure that no new defects are introduced by updates or fixes.
Performance Testing: Evaluate software performance under different conditions, ensuring scalability and reliability.
Collaboration: Work with developers, product owners, and project managers to refine requirements and deliver a high-quality product.
**Example Task:**

Writing automated test scripts to validate that a web application correctly processes user input under various scenarios.

**Project Manager**
Role:
A project manager (PM) is responsible for planning, executing, and delivering software projects within time and budget constraints. They oversee the development process, manage the team, and act as a bridge between stakeholders and the development team.

Responsibilities:

Project Planning: Create detailed project plans, timelines, and milestones based on the project's scope and objectives.
Task Allocation: Assign tasks to team members, ensure they are properly equipped to handle the workload, and track progress.
Risk Management: Identify potential risks and roadblocks that could affect the project’s success and develop mitigation strategies.
Communication: Act as the primary point of contact for stakeholders, ensuring they are updated on the project’s status and any issues that arise.
Budget and Resource Management: Monitor and manage the project’s budget and allocate resources efficiently to ensure cost-effective delivery.
Stakeholder Management: Gather feedback from stakeholders, clarify requirements, and align the development team’s efforts with business goals.
Project Documentation: Ensure proper documentation of the project plan, decisions, and progress, and conduct post-project reviews to capture lessons learned.
**Example Task:**

Developing a Gantt chart to track the timeline for delivering a new feature in a mobile app while coordinating with clients and development teams to ensure deadlines are met.



Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated Development Environments (IDEs) are software applications that provide comprehensive facilities for software development. 
**Importance of IDEs includes;**
Efficiency: IDEs centralize all development tasks in one place, reducing the time spent switching between tools and improving productivity.
Error Reduction: Real-time error detection, code suggestions, and debugging tools help developers catch mistakes early, reducing the time spent troubleshooting.
Collaboration: Many IDEs provide features like live sharing of code, enabling developers to work collaboratively in real-time, even from different locations.
Examples of IDEs:

Visual Studio Code: A popular, lightweight IDE with a rich extension ecosystem. It supports various programming languages like JavaScript, Python, and C#.
IntelliJ IDEA: Widely used for Java development but also supports many other languages. It offers advanced features like code refactoring and built-in Git support.
Eclipse: A robust, open-source IDE that supports Java, C++, Python, and other languages. Known for its plugin architecture and extensibility.

Version Control Systems (VCS) allow developers to track changes in their codebase over time, manage multiple versions of software, and collaborate effectively with team members.
**Importance of VCS includes**
Team Collaboration: In modern software teams, multiple developers are often working on the same project simultaneously. VCS allows for smooth collaboration by handling code merges and version conflicts automatically.
Change Management: VCS provides a clear record of changes, making it easy to understand the evolution of the codebase and identify when and why specific changes were introduced.
Disaster Recovery: If errors or bugs are introduced into the software, developers can quickly roll back to previous stable versions, ensuring that the project is not permanently damaged.
Release Management: VCS supports tagging specific commits or branches as official releases, enabling a clear and organized software release cycle.
Examples of VCS:
Git: A distributed version control system that allows developers to clone repositories locally, make changes, and then push them to a shared repository. Git is highly scalable and is the backbone of many development workflows.
Subversion (SVN): A centralized version control system that keeps all versions of files on a central server. It's used in more controlled environments where centralization and tighter control over changes are important.
Mercurial: A distributed version control system similar to Git, but designed to be simpler and more lightweight.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. **Managing Project Complexity**
Challenge:
As software projects grow larger, the complexity increases, making it difficult to maintain code quality, manage dependencies, and ensure that all components work together seamlessly. This can lead to unmanageable codebases, slower development, and more bugs.

Strategies to Overcome:

Modularization: Break down the system into smaller, manageable modules or components. Each module should handle a specific function, which makes it easier to develop, test, and maintain.
Design Patterns: Use established design patterns such as MVC (Model-View-Controller) or Observer, which provide reusable solutions to common software design problems.
Documentation: Maintain thorough documentation for code, system architecture, and dependencies. Clear documentation helps all team members understand how different parts of the system interact.
Regular Refactoring: Continuously refactor the code to improve its structure and remove technical debt, keeping the codebase clean and maintainable over time.
2. Time Management and Meeting Deadlines
Challenge:
Software projects often have tight deadlines, and engineers may struggle to manage their time effectively, especially when dealing with unforeseen issues like bugs or changing requirements.

Strategies to Overcome:

Agile Methodology: Adopt agile practices, such as Scrum or Kanban, to break the project into smaller tasks (sprints) with clear, short-term goals. This helps engineers focus on immediate priorities and track progress.
Prioritization: Use frameworks like the Eisenhower Matrix or MoSCoW method to prioritize tasks based on their importance and urgency. Focus on the critical features first to ensure timely delivery.
Time Blocking: Allocate specific time slots for focused work on particular tasks and avoid multitasking, which can decrease productivity.
Buffer Time: Account for potential delays and unforeseen challenges by building buffer time into project timelines. This reduces stress and improves the likelihood of meeting deadlines.
3. Handling Changing Requirements
Challenge:
Frequent changes in project requirements, especially late in the development cycle, can disrupt the development process, lead to rework, and cause frustration for software engineers.

Strategies to Overcome:

Agile Development: Agile’s iterative nature allows teams to embrace changing requirements, even late in the development process. Regular feedback loops ensure that engineers are always aligned with stakeholders.
Communication: Foster continuous communication with stakeholders and clients to clarify requirements, understand the rationale behind changes, and adjust plans accordingly.
Version Control: Use version control systems like Git to manage changes. Branching and merging strategies (e.g., GitFlow) help keep code stable even as changes are introduced.
Documentation and Prototyping: Clearly document requirements and use prototyping or mockups to validate them before fully committing to development. This helps identify potential issues or changes early on.
4. Debugging and Fixing Bugs
Challenge:
Bugs are inevitable in software development and can be challenging to trace, especially in large codebases. Some bugs may only surface under certain conditions, making them hard to replicate and fix.

Strategies to Overcome:

Automated Testing: Implement unit tests, integration tests, and end-to-end tests to catch bugs early in the development process. This reduces the likelihood of bugs reaching production.
Debugging Tools: Use debugging tools built into Integrated Development Environments (IDEs) like Visual Studio Code, IntelliJ IDEA, or Eclipse to step through code and identify the root cause of issues.
Logging and Monitoring: Integrate logging and monitoring tools (e.g., Log4j, Splunk, or Prometheus) to capture detailed information about the system’s runtime behavior, which helps in identifying where bugs occur.
Code Reviews: Regular code reviews by peers can help catch potential bugs or bad practices before code is merged. This creates an additional layer of quality control.



Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit Testing
Definition:

Unit testing focuses on testing individual units or components of the software, typically at the function or method level. Each "unit" is the smallest testable part of the software, such as a function, class, or module.
Goal:

The purpose of unit testing is to verify that each individual part of the software behaves as expected in isolation, without interference from other parts of the system.
Tools:

Popular unit testing frameworks include JUnit for Java, NUnit for .NET, PyTest for Python, and Jest for JavaScript.
Importance:

Early Bug Detection: Unit tests catch bugs early in the development process, allowing developers to fix issues before they escalate.
Improved Code Quality: Writing unit tests encourages developers to write modular, testable, and clean code.
Faster Debugging: When tests are isolated, it's easier to pinpoint exactly where the failure occurs.
Regression Prevention: Unit tests ensure that changes in one part of the code do not break other parts unintentionally.
2. Integration Testing
Definition:

Integration testing focuses on testing the interactions between different units or components to ensure they work together as expected. After individual units have been tested in isolation, integration testing ensures that the system's modules or services function correctly when combined.
Types of Integration Testing:

Big Bang Integration: All units are combined and tested together at once.
Incremental Integration: Units are integrated and tested in stages. This can be done in two ways:
Top-Down: Higher-level modules are tested first, followed by lower-level modules.
Bottom-Up: Lower-level modules are tested first, and higher-level modules are added later.
Tools:

JUnit, TestNG, or Mocha (depending on the language), as well as specific tools like Postman for testing API integrations.
Importance:

Ensures Collaboration Between Modules: Integration tests ensure that individual components work together correctly, which is especially important in large systems with many dependencies.
Early Detection of Interface Issues: They help identify issues in communication between modules (e.g., incorrect data formats, missing data, or miscommunication between services).
Reduces Risk of System Failure: Integration testing mitigates the risk of system-wide failures by identifying issues in the early stages of module integration.
3. System Testing
Definition:

System testing evaluates the complete and integrated software system as a whole. It ensures that the entire system meets the specified requirements and functions as expected in a real-world environment. System testing involves testing the software in an environment that closely mimics production.
Types of System Testing:

Functional Testing: Verifies that the system performs the intended functions as per the requirements.
Non-Functional Testing: Evaluates aspects like performance, scalability, security, and usability.
End-to-End Testing: Tests the complete flow of the system from start to finish, ensuring all components interact correctly.
Tools:

Tools like Selenium (for web applications), JMeter (for performance testing), and LoadRunner (for load testing) are commonly used for system testing.
Importance:

Validates Entire System Functionality: System testing ensures that the integrated software functions as expected under various conditions, mimicking how users will interact with it.
Detects System-Wide Issues: It catches issues that might arise only when all components are working together, such as integration problems, configuration errors, or overall system performance.
Ensures Compliance with Requirements: System testing checks whether the software satisfies both functional and non-functional requirements set by the stakeholders.
4. Acceptance Testing
Definition:

Acceptance testing is the final level of testing before the software is released to the customer. It ensures that the software meets the user’s needs and requirements. This type of testing is usually conducted by the end users or clients to validate that the software works as intended in real-world scenarios.
Types of Acceptance Testing:

User Acceptance Testing (UAT): End users test the software to validate whether it meets their needs and is ready for production.
Operational Acceptance Testing (OAT): Also known as production acceptance testing, OAT evaluates whether the software is ready for deployment from an operational standpoint (e.g., backup, recovery, and maintainability).
Contract Acceptance Testing (CAT): Ensures the software adheres to the contract specifications agreed upon by the client and developer.
Tools:

Tools like FitNesse, Cucumber, or custom scripts are often used for acceptance testing, depending on the project.
Importance:

Ensures User Satisfaction: Acceptance testing ensures that the final product meets user expectations and requirements, reducing the chances of post-deployment issues.
Real-World Testing: It provides feedback on how the system will behave in real-world use cases, identifying any last-minute issues that may have been overlooked during other testing phases.
Final Quality Check: It acts as the final validation before the software is released into production, providing confidence that the product is ready for use.



#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
**Prompt engineering** refers to the process of crafting and refining prompts or input queries to interact effectively with AI models, especially large language models (LLMs) like GPT. The goal of prompt engineering is to structure the input in such a way that it elicits the desired response from the AI. Since LLMs generate responses based on the input they receive, the way the prompt is framed can significantly influence the quality, relevance, and accuracy of the output.

Key Elements of Prompt Engineering
Context and Clarity: Providing clear and unambiguous input that offers sufficient context for the AI to understand the task or question.
Instructions: Giving direct or implicit instructions on the format, style, or type of response desired.
Examples: Including examples or templates to guide the AI towards generating specific responses.
Constraints: Setting boundaries, such as length limits, tone, or style, to ensure the response fits the user’s needs.
Importance of Prompt Engineering in AI Interaction
Optimizing Response Quality:
Well-crafted prompts help users get more accurate, coherent, and relevant answers from the AI. For instance, instead of simply asking "What is software engineering?", a more detailed prompt like "Explain what software engineering is, its importance, and its evolution in the tech industry" can yield a more comprehensive and tailored response.

Controlling Output Format and Style:
Prompt engineering allows users to define how they want the AI to respond. For example, by specifying that the response should be in the form of a summary, a list, or formal language, users can better match the output to their requirements.

Addressing Ambiguity:
Poorly structured prompts can lead to vague or irrelevant answers. By crafting precise prompts, users can minimize ambiguity and guide the AI toward more focused responses.

Adapting to Different Use Cases:
From generating code to writing essays or conducting research, prompt engineering tailors the AI's capabilities to specific tasks. For example, in creative writing, prompts can guide the AI to generate a certain tone or style, while in coding tasks, prompts can focus on syntax and functionality.

Mitigating Bias or Misinterpretation:
Well-designed prompts can help reduce biases or misinterpretations by providing clear and neutral language. This helps AI models generate more accurate and impartial responses.

Enhancing User Productivity:
Effective prompt engineering maximizes the utility of AI models, helping users save time by generating responses that are close to what they need without requiring excessive editing or iteration.

Example of Prompt Engineering in Action
Unoptimized Prompt:
"Describe machine learning."

Optimized Prompt:
"Provide a detailed explanation of machine learning, including its definition, key concepts like supervised and unsupervised learning, and its real-world applications in industries such as healthcare and finance."


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

**Example of a Vague Prompt:**
"Tell me about technology."

Why it’s vague:

The term "technology" is too broad, and it’s unclear what specific information is being requested. The AI could respond with information about anything from the history of technology to recent advancements in various fields, which may not align with the user’s intent.
Improved Prompt:
"Explain the impact of AI technology on the healthcare industry, including examples of how AI is used for diagnostics and patient care."

Why the improved prompt is more effective:

Clear Focus: The improved prompt specifies that the topic is AI technology, not technology in general.
Specific Domain: It narrows down the area of interest to healthcare, making it clear which industry’s impact should be discussed.
Concise Objective: The request for examples of AI's use in diagnostics and patient care provides the AI with a clear direction on what to include in the response.
Benefits of the Improved Prompt:
Relevance: The AI will generate a response closely aligned with the user's intent, focusing on AI in healthcare.
Detail: By asking for specific use cases (diagnostics and patient care), the response will provide detailed, actionable information.
Efficiency: The improved prompt eliminates guesswork, resulting in a more direct and useful answer, saving time and effort for both the user and the AI.

